/*
 * uart1.c
 *
 *  Created on: May 1, 2025
 *      Author: tynix
 */

#include "uart1.h"

void uart1_config(uint32_t baud) {

	// UART TX is PA9 or D8

	// enable clock
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;

	// select alternate function mode for PA9
	GPIOA->MODER |= GPIO_MODER_MODER9_1;
	GPIOA->MODER &= ~GPIO_MODER_MODER9_0;

	// select UART_TX1 as AF
	GPIOA->AFR[1] |= GPIO_AFRH_AFRH1_2 | GPIO_AFRH_AFRH1_1 | GPIO_AFRH_AFRH1_0;


	// enable USART1 clock
	RCC->APB2ENR |= RCC_APB2ENR_USART1EN;

	USART1->CR1 |= USART_CR1_UE;		// USART enable
	USART1->CR1 &= ~USART_CR1_M;		// 1 start bit, 8 data bits, n stop bits
	USART1->CR1 &= ~USART_CR1_PCE;		// no parity

	USART1->CR2 = 0;					// 1 stop bit, asynchronous

	// USARTDIV = fCK / (8 * (2 - OVER8) * baud)
	// fCK = 84MHz (APB2 bus)
	// Ex. baud = 9600
	// USARTDIV = 546.875
	// Mantissa = 546
	// Fraction = 0.875 * 16 (4 bits for fraction) = 14
	float usartdiv = (float) 84000000 / (16 * baud);
	uint16_t mantissa = (uint16_t) usartdiv;
	uint8_t fraction = (uint8_t) ((usartdiv - mantissa) * 16);
	USART1->BRR = mantissa << 4 | fraction;

	USART1->CR1 |= USART_CR1_TE;		// enable transmitter
}


void uart1_writebyte(uint8_t byte) {

	while (!(USART1->SR & USART_SR_TXE));		// wait until data register is empty
	USART1->DR = byte;			// load register
	while (!(USART1->SR & USART_SR_TC));		// wait until transmission complete
}


void uart1_writeint(int num) {

	if (num < 0)
		uart1_writebyte('-');

	num = abs(num);
	int power = floor(log10(num));		// calculate power of 10

	for (int i = pow(10, power); i > 0; i /= 10)
		uart1_writebyte((num / i) % 10 + '0');
}


void uart1_writestr(char * str) {

	int i = 0;
	while (str[i] != '\0')
		uart1_writebyte(str[i++]);
}
