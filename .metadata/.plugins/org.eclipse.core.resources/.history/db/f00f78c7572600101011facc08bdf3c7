/**
  ******************************************************************************
  * @file     lib.c
  * @author   Auto-generated by STM32CubeIDE
  * @version  V1.0
  * @date     01/05/2025 01:34:13
  * @brief    Default under dev library file.
  ******************************************************************************
*/

/* Includes ------------------------------------------------------------------*/
#include "stm32f4xx_hal.h"
#include <stdint.h>

void i2c1_config() {

	// PB8 is SCL
	// PB9 is SDA
	// enable I2C clock before configuring pins
	RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;			// enable I2C1 clock
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOBEN;		// enable GPIO clock

	// before configuring SCL and SDA pins for AF, make sure bus is not busy by clocking out extra
	// data to slave devices
	i2c1_release();


	// set AF mode for SCL and SDA
	GPIOB->MODER |= GPIO_MODER_MODE9_1 | GPIO_MODER_MODE8_1;
	GPIOB->MODER &= ~(GPIO_MODER_MODE9_0 | GPIO_MODER_MODE8_0);

	// set open-drain for both lines
	GPIOB->OTYPER |= GPIO_OTYPER_OT9 | GPIO_OTYPER_OT8;

	// enable pull ups (already on board)

	// set max output speed for both
	GPIOB->OSPEEDR |= GPIO_OSPEEDER_OSPEEDR9 | GPIO_OSPEEDER_OSPEEDR8;

	// AF04 for PB8 and PB9 to select I2C1_SCL and I2C1_SDA
	GPIOB->AFR[1] |= GPIO_AFRH_AFRH0_2 | GPIO_AFRH_AFRH1_2;


	// I2C steps in sequence (per data sheet)
	// 1. Disable peripheral
	// 2. Program peripheral input clock to generate correct timing
	// 3. Configure clock control registers
	// 4. Configure rise time
	// 5. Enable peripheral
	// 6. Start bit
	I2C1->CR1 = 0;		// disable peripheral
	i2c1_sw_rst();		// reset I2C to clear busy bit
	I2C1->CR2 = 42;		// configure peripheral input clock freq to 42MHz (APB1 clock)

	// 300kHz fast mode
	// Since FREQ = 42MHz, tPCLK = 23.8ns
	// tLOW = 2 * tHIGH
	// 300kHz = 1 / (tLOW + tHIGH) = 1 / (3 * tHIGH)
	// tHIGH = 1.11us
	// tHIGH = CCR * tPCLK
	// CCR = 46.667
	I2C1->CCR = I2C_CCR_FS | 47;	// fast mode and set freq to 300kHz
	// max SCL tRISE is 300ns
	// tPCLK = 23.8ns
	// tRISE / tPCLK + 1 = 12.6 + 1 = 13.6
	I2C1->TRISE = 13;

	I2C1->CR1 |= I2C_CR1_PE;	// enable peripheral
}


void i2c1_sw_rst() {

	// reset I2C1
	I2C1->CR1 |= I2C_CR1_SWRST;
	I2C1->CR1 &= ~I2C_CR1_SWRST;
}


void i2c1_writebyte(uint8_t slave_addr, uint8_t reg_addr, uint8_t byte) {

	while (I2C1->SR2 & I2C_SR2_BUSY);

	i2c1_start();
	I2C1->DR = slave_addr;
	while (!(I2C1->SR1 & I2C_SR1_ADDR));
	(void)I2C1->SR2;						// dummy read to clear status bit
	while (!(I2C1->SR1 & I2C_SR1_TXE));		// data register needs to be empty
	I2C1->DR = reg_addr;					// set pointer on BNO055
	while (!(I2C1->SR1 & I2C_SR1_TXE));		// data register needs to be empty
	I2C1->DR = byte;
	while (!(I2C1->SR1 & I2C_SR1_TXE));
	i2c1_request_stop();
}


uint8_t i2c1_readbyte(uint8_t slave_addr, uint8_t reg_addr) {

	while (I2C1->SR2 & I2C_SR2_BUSY);

	i2c1_start();
	I2C1->DR = slave_addr;
	while (!(I2C1->SR1 & I2C_SR1_ADDR));
	(void)I2C1->SR2;						// dummy read to clear status bit
	while (!(I2C1->SR1 & I2C_SR1_TXE));		// data register needs to be empty
	I2C1->DR = reg_addr;					// set pointer on BNO055
	while (!(I2C1->SR1 & I2C_SR1_TXE));		// data register needs to be empty

	// For single byte reads, pg 482 of reference manual "Closing the communication"
	i2c1_start();
	I2C1->DR = slave_addr | 0x01;			// read mode
	while (!(I2C1->SR1 & I2C_SR1_ADDR));
	i2c1_nack();
	(void)I2C1->SR2;						// dummy read to clear status bit
	i2c1_request_stop();
	while (!(I2C1->SR1 & I2C_SR1_RXNE));	// wait for full data register
	return I2C1->DR;
}


void i2c1_readburst(uint8_t slave_addr, uint8_t reg_addr, uint8_t len, uint8_t * bytes) {

	if (len == 0)
		return;

	while (I2C1->SR2 & I2C_SR2_BUSY);

	i2c1_start();
	I2C1->DR = slave_addr;
	while (!(I2C1->SR1 & I2C_SR1_ADDR));
	(void)I2C1->SR2;						// dummy read to clear status bit
	while (!(I2C1->SR1 & I2C_SR1_TXE));		// data register needs to be empty
	I2C1->DR = reg_addr;					// set first pointer on BNO055
	while (!(I2C1->SR1 & I2C_SR1_TXE));		// data register needs to be empty

	i2c1_start();
	I2C1->DR = slave_addr | 0x01;			// read mode
	while (!(I2C1->SR1 & I2C_SR1_ADDR));

	// acknowledge next byte if burst >1 byte
	if (len != 1)
		(void)I2C1->SR2;

	for (uint8_t i = 0; i < len - 1; i++) {

		i2c1_ack();
		while (!(I2C1->SR1 & I2C_SR1_RXNE));	// wait for full data register
		*bytes = I2C1->DR;					// store byte
		bytes++;							// move pointer
	}

	i2c1_nack();								// clear ACK bit just after reading second last data byte
	if (len == 1)
		(void)I2C1->SR2;
	i2c1_request_stop();
	while (!(I2C1->SR1 & I2C_SR1_RXNE));	// wait for full data register
	*bytes = I2C1->DR;
}


void i2c1_start() {

	I2C1->CR1 |= I2C_CR1_START;
	while (!(I2C1->SR1 & I2C_SR1_SB));		// wait for start bit generation
}

void i2c1_request_stop() {

	I2C1->CR1 |= I2C_CR1_STOP;
}

void i2c1_ack() {

	I2C1->CR1 |= I2C_CR1_ACK;
}

void i2c1_nack() {

	I2C1->CR1 &= ~I2C_CR1_ACK;
}


void i2c1_release() {

	// set SCL and SDA lines as outputs
	GPIOB->MODER |= GPIO_MODER_MODER9_0 | GPIO_MODER_MODER8_0;
	GPIOB->MODER &= ~(GPIO_MODER_MODER9_1 | GPIO_MODER_MODER8_1);

	// output open drain
	GPIOB->OTYPER |= GPIO_OTYPER_OT9 | GPIO_OTYPER_OT8;

	// set SDA line high, so that after slave releases the SDA and listens for ACK/NACK, it will get NACK
	GPIOB->ODR |= GPIO_ODR_ODR_9;

	// generate 10 clock pulses on SCL line
	for (int i = 0; i < 10; i++) {

		GPIOB->ODR |= GPIO_ODR_ODR_8;
		for (int j = 0; j < 1000; j++)
			__NOP();

		GPIOB->ODR &= ~GPIO_ODR_ODR_8;
		for (int j = 0; j < 1000; j++)
			__NOP();
	}

	// set SCL high, line should be pulled high when I2C is idle
	GPIOB->ODR |= GPIO_ODR_ODR_8;
}
